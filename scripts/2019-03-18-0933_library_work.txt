## Resuming library creation work.
## On Yeti.

cd /home/mattbowser/AK_arhropod_COI_library

R

de1 <- read.delim("2019-03-15-1439_derep.txt", header=FALSE)
dim(de1)
[1] 661152     10

de2 <- de1[1:391167, 9:10]
names(de2) <- c("Query", "Target")
sl <- grepl("\\*", de2$Target)
de2$Query <- as.character(de2$Query)
de2$Target <- as.character(de2$Target)
de2$Target[sl] <- de2$Query[sl]
dim(de2)
[1] 391167      2

ak <- read.delim("Alaska.txt", quote="", stringsAsFactors = FALSE)
bc <- read.delim("British_Columbia.txt", quote="", stringsAsFactors = FALSE)
yk <- read.delim("Yukon_Territory.txt", quote="", stringsAsFactors = FALSE)
ru <- read.delim("Russia.txt", quote="", stringsAsFactors = FALSE)

d1 <- rbind(ak, bc, yk, ru)
dim(d1)
[1] 415779     68

tg <- levels(as.factor(de2$Target))
length(tg)
[1] 269727

## Now for each target I want to select one of the records with the most complete data.

## First make a dataframe to put results in.
Target <- tg
rdf <- as.data.frame(tg)
rdf$rep <- NA ## for selected representative sequence records.

this_tg <- 1 ## for testing.
for (this_tg in 1:length(tg)) # length(tg)
 {
 
 ## First make dataframe of records with matching sequences.
 ttg <- tg[this_tg]
 qr <- de2$Query[which(de2$Target == ttg)] 
 sl <- which(d1$processid %in% qr)
 qdf <- d1[sl,]
 qdf$lt <- paste(qdf$class_name, qdf$order_name, qdf$family_name, qdf$species_name)
 
 ## If there are any species identifications, choose these.
 if (sum(is.na(qdf$species_name)) > 0)
  {
  sl <- !(is.na(qdf$species_name))
  qdf <- qdf[sl,]
  } 
 
 ## If there are no species IDs just pick the longest taxonomy.
 if (sum(!is.na(qdf$species_name)) == 0) 
  {
  mxlt <- max(nchar(qdf$lt))
  sl <- nchar(qdf$lt) == mxlt
  qdf <- qdf[sl,]
  }
 
 ## If some have BINs and some don't, choose the ones with BINS.
 if (sum(is.na(qdf$bin_uri)) > 0)
  {
  sl <- !(is.na(qdf$bin_uri))
  qdf <- qdf[sl,]
  }
  
 ## Now if some records are from Alaska, choose these.
  if (sum(qdf$province_state %in% "Alaska") > 0)
  {
  sl <- qdf$province_state %in% "Alaska"
  qdf <- qdf[sl,]
  }
 
 ## Now just make a random choice.
 sl <- sample(qdf$processid, size=1)
 
 ## Now populate that dataframe.
 rdf$rep[this_tg] <- sl
 
 }

## That is taking forever.  I think that this dataset is far too big and that I need to cluster at the 99% level or something.  For comparison, the largest version of the UNITE database has 9,409 RefS's and 112,778 RepS's.

## Again consulting http://manpages.org/vsearch
 

 
 ## Which iddef should I use and should I use consensus sequences or centroids?
 ## Looks like I should use centroids and not consensus. Consensus
 ## Consulted https://www.drive5.com/usearch/UsearchUserGuide4.1.pdf
 ## Going with --iddef 0, the default.

## Stopped that.
## Saving image.
save.image("2019-03-18-1358_workspace.RData")
 
 
## Killed R. 
 
module load genetics/vsearch-2.4.3 
 
vsearch --cluster_fast 2019-03-15-1426_lib.fas \
 --centroids 2019-03-18-1357_clusters.fas \
 --uc 2019-03-18-1357_derep.txt \
 --id 0.99\
 --iddef 0 
vsearch v2.4.3_linux_x86_64, 125.9GB RAM, 20 cores
https://github.com/torognes/vsearch

Reading file 2019-03-15-1426_lib.fas 100%
251623261 nt in 391167 seqs, min 63, max 1951, avg 643
Masking 100%
Sorting by length 100%
Counting unique k-mers 100%
Clustering 100%
Sorting clusters 100%
Writing clusters 100%
Clusters: 140257 Size min 1, max 629, avg 2.8
Singletons: 91226, 23.3% of seqs, 65.0% of clusters
 
wc -l 2019-03-18-1357_clusters.fas
1324334 2019-03-18-1357_clusters.fas
head 2019-03-18-1357_clusters.fas

sed -n '1,100p' 2019-03-18-1357_clusters.fas

## Interesting.  This is a multiple line per sequence fasta file.

sed -n '1,100p' 2019-03-18-1357_derep.txt 
wc -l 2019-03-18-1357_derep.txt
531424 2019-03-18-1357_derep.txt

So went from 391K clusters to 140K clusters.

module purge

module load R/3.5.1-gcc7.1.0

R

de1 <- read.delim("2019-03-18-1357_derep.txt", header=FALSE)
dim(de1)
[1] 531424     10

de2 <- de1[, 9:10]
names(de2) <- c("Query", "Target")
sl <- grepl("\\*", de2$Target)
de2$Query <- as.character(de2$Query)
de2$Target <- as.character(de2$Target)
de2$Target[sl] <- de2$Query[sl]
de2 <- unique(de2)
dim(de2)
[1] 390923      2

ak <- read.delim("Alaska.txt", quote="", stringsAsFactors = FALSE)
bc <- read.delim("British_Columbia.txt", quote="", stringsAsFactors = FALSE)
yk <- read.delim("Yukon_Territory.txt", quote="", stringsAsFactors = FALSE)
ru <- read.delim("Russia.txt", quote="", stringsAsFactors = FALSE)

d1 <- rbind(ak, bc, yk, ru)
dim(d1)
[1] 415779     68

tg <- levels(as.factor(de2$Target))
length(tg)
[1] 140093  #Whoa, I expected more.

## Now for each target I want to select one of the records with the most complete data.

## First make a dataframe to put results in.
Target <- tg
rdf <- as.data.frame(tg)
rdf$rep <- NA ## for selected representative sequence records.

this_tg <- 1 ## for testing.
for (this_tg in 1:length(tg)) # length(tg)
 {
 
 ## First make dataframe of records with matching sequences.
 ttg <- tg[this_tg]
 qr <- de2$Query[which(de2$Target == ttg)] 
 sl <- which(d1$processid %in% qr)
 qdf <- d1[sl,]
 qdf$lt <- paste(qdf$class_name, qdf$order_name, qdf$family_name, qdf$species_name)
 
 ## If there are any species identifications, choose these.
 if (sum(is.na(qdf$species_name)) > 0)
  {
  sl <- !(is.na(qdf$species_name))
  qdf <- qdf[sl,]
  } 
 
 ## If there are no species IDs just pick the longest taxonomy.
 if (sum(!is.na(qdf$species_name)) == 0) 
  {
  mxlt <- max(nchar(qdf$lt))
  sl <- nchar(qdf$lt) == mxlt
  qdf <- qdf[sl,]
  }
 
 ## If some have BINs and some don't, choose the ones with BINS.
 if (sum(is.na(qdf$bin_uri)) > 0)
  {
  sl <- !(is.na(qdf$bin_uri))
  qdf <- qdf[sl,]
  }
  
 ## Now if some records are from Alaska, choose these.
  if (sum(qdf$province_state %in% "Alaska") > 0)
  {
  sl <- qdf$province_state %in% "Alaska"
  qdf <- qdf[sl,]
  }
 
 ## Now just make a random choice.
 sl <- sample(qdf$processid, size=1)
 
 ## Now populate that dataframe.
 rdf$rep[this_tg] <- sl
 
 }

write.csv(rdf, "2019-03-18-1431_selected_records.csv", row.names="FALSE")

